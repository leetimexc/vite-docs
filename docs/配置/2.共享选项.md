对 Vite 官方文档 [共享选项](https://cn.vitejs.dev/config/shared-options.html) 的理解。

### root

- 类型： string
- 默认： process.cwd()

用于指定项目的根目录位置，也就是 index.html 文件所在的文件夹。

**核心原因 ‌：** Vite 需要找到 index.html 作为应用的入口文件，才能正确地将 Vue 组件渲染到页面上。

**‌ 具体流程 ‌：**

1. ‌Vite 启动 ‌ 时，首先要找到 index.html
2. 在 index.html 中 ‌，通常有这样的代码：

   ```html
   <div id="app"></div>
   <script type="module" src="/src/main.js"></script>
   ```

3. **通过这个入口**‌ ，Vite 才能加载 Vue 应用，并把组件渲染到指定的 DOM 元素中。

#### ‌ 为什么需要 root 配置 ‌：

- 如果项目结构特殊（比如配置文件不在根目录）
- 或者有多个项目共用配置
- Vite 就不知道去哪里找这个 index.html
- 设置 root 就是明确告诉 Vite 入口文件的位置

**简单说：root 配置就是给 Vite 一个明确的"地图"，让它能找到渲染 Vue 组件的"画布"（HTML 文件）**

---

### base

- 类型： string
- 默认： /

base 配置其实就是**设置你的网站在服务器上的"存放位置"‌**

#### 简单理解：

- 如果你的网站直接放在服务器根目录，base 就是 /
- 如果你的网站放在某个子文件夹里，比如 admin 文件夹，base 就是 /admin/

#### ‌ 具体场景举例：‌

1. 默认情况 ‌（base = "/"）

- 网站地址：https://example.com
- 资源路径：https://example.com/js/app.js

2. 子目录部署 ‌（base = "/admin/"）

- 网站地址：https://example.com/admin/
- 资源路径：https://example.com/admin/js/app.js

#### ‌ 为什么需要这个配置？

当你的项目部署到非根目录时，如果不设置正确的 base：

- 图片、CSS、JS 等资源加载失败
- 路由跳转出错
- 页面显示空白（白屏）

#### 合法的 base 值类型：‌

- /foo/ - 部署到 foo 子目录
- https://bar.com/foo/ - 完整 URL（开发时域名部分忽略）
- ./ 或空字符串 - 用于嵌入式开发

#### 实际应用：

比如你的项目要部署到公司官网的 `/vite-project/` 路径下，就在 vite.config.ts 中配置：

```javascript
export default defineConfig({
  base: "/vite-project/",
});
```

这样打包后所有资源路径都会自动加上 `/vite-project/` 前缀，确保在生产环境正常访问

---

### mode

- 类型： string
- 默认： 'development' 用于开发，'production' 用于构建

#### Vite 会根据你设置的 mode 值，自动切换不同的工作模式，实现开发和生产环境的差异化处理。

**开发模式 (development)‌**

- 构建工具:（快速编译）
- 浏览器:（详细的错误提示）
- 代码:（代码不压缩，可读性强）

**生产模式 (production)‌**

- 构建工具:（代码压缩和优化）
- 浏览器: （简洁的错误信息）
- 代码:（代码被压缩，体积小，加载快）

#### 那如果我配置了自定义 mode vite 怎么会判断是开发 还是生产？

Vite 通过以下几种方式来判断当前是开发环境还是生产环境：

1. 环境判断机制

   - import.meta.env.MODE 和 process.env.NODE_ENV 这两个环境变量来识别当前运行模式
   - 无论你设置什么自定义 mode，只要 NODE_ENV 不是 'production'，Vite 就会将其视为开发环境

2. 默认行为规则
   - 运行 vite 命令时默认使用 'development' 模式
   - 运行 vite build 命令时默认使用 'production' 模式
3. 环境变量优先级

   1. 首先加载 .env 文件中的全局配置
   2. 然后根据当前 mode 加载对应的环境文件（如 .env.development、.env.production）
   3. 最后应用命令行指定的 mode

4. 实际应用示例

   ```json
   {
     "scripts": {
       "dev": "vite --mode development",
       "test": "vite --mode test"
     }
   }
   ```

5. 关键判断标准

   - 最核心的判断依据是 NODE_ENV 的值
   - 当 NODE_ENV 明确设置为 'production' 时，Vite 才会启用生产环境的优化配置

6. 最佳实践建议

   为了确保环境判断的准确性，建议：

   - 在 .env.development 中设置 NODE_ENV = 'development'
   - 在 .env.production 中设置 NODE_ENV = 'production'
   - 在 package.json 中明确指定各命令对应的 mode

**Vite 主要看 NODE_ENV 这个关键变量来判断环境，自定义 mode 主要用于区分不同的业务场景，而不影响核心的环境判断逻辑**

#### 在实际项目中怎么用？

1. 在配置文件里设置 (vite.config.js)

   ```javascript
   export default {
     // 当运行 `vite` 命令时，默认就是这个模式
     mode: "development",
   };
   ```

2. 在命令行里覆盖

   ```bash
   # 用开发模式启动
   vite --mode development

   # 用生产模式打包
   vite build --mode production
   ```

#### 为什么这个功能很重要？

因为它让你可以写“智能代码”，同一份代码在不同环境下表现不同：

```javascript
// 这段代码能自动识别当前环境
if (import.meta.env.MODE === "development") {
  // 只有开发时才启用调试工具
  console.log("这是详细的调试信息");
} else {
  // 生产环境就保持简洁
  console.log("系统提示");
}
```

#### NODE_ENV 和 mode 的区别？

- NODE_ENV 确实是传统的环境变量，用来区分开发和生产环境
- mode 是 Vite 自定义的，用于区分不同的业务场景，而不影响核心的环境判断逻辑

#### NODE_ENV 就像天气 ‌

- 只有两种：晴天（production）或阴天（development）
- 影响全局，比较粗糙

#### Vite 的 mode 就像具体的活动安排 ‌

- 可以有更多选择：开发、测试、预发布、生产等
- 更精细，可以针对不同场景做特定配置

#### ‌ 实际关系：‌

- Vite 内部还是会看 NODE_ENV 来做基础判断
- 但 mode 让你可以创建更多"子环境"

**比如你可以在开发阶段设置不同的模式：**

```bash
# 本地开发
vite --mode development

# 测试环境
vite --mode test

# 演示环境
vite --mode demo
```

**然后在代码中根据具体模式做更精细的控制：**

```javascript
if (import.meta.env.MODE === "test") {
  // 测试环境的特殊逻辑
  mockAPI(); // 使用模拟数据
}
```

所以 **mode** 是对 **NODE_ENV** 的扩展和补充，让你有更灵活的环境管理能力。

---

### define

**define 就是一个"查找替换"工具 ‌，** 它能在你打包代码时自动把特定的变量名换成实际的值

#### 它具体做什么？

想象你在写代码时经常要用到应用版本号，比如：

```javascript
// 如果没有 define，你需要手动写版本号，再这些地方都写一遍
console.log("场景1-当前版本：" + __APP_VERSION__);
console.log("场景2-当前版本：" + __APP_VERSION__);
console.log("场景3-当前版本：" + __APP_VERSION__);
console.log("场景4-当前版本：" + __APP_VERSION__);
console.log("场景5-当前版本：" + __APP_VERSION__);
console.log("场景6-当前版本：" + __APP_VERSION__);
console.log("场景7-当前版本：" + __APP_VERSION__);
console.log("场景8-当前版本：" + __APP_VERSION__);
```

有了 define，你只需要在配置里定义一次：

```javascript
// 打包时，Vite 会自动把代码里所有的 __APP_VERSION__ 都换成 "v1.0.0"
export default defineConfig({
  define: {
    __APP_VERSION__: "1.0.0",
  },
});
```

#### 两种常见用法

1. ‌ 直接替换成固定值

   ```javascript
   // 这样代码中的 __APP_VERSION__ 就变成了硬编码的字符串 "v1.0.0"
   // 静态替换，需要重新构建项目
   __APP_VERSION__: JSON.stringify("v1.0.0");
   ```

2. 替换成运行时变量

   ```javascript
   // 这样代码会去读取浏览器中 window 对象上的值
   // 动态替换，不需要重新构建项目，只需要更新 HTML 中的配置值即可动态调整 API 地址
   __API_URL__: "window.__backend_api_url";
   ```

   ```html
   <!-- 在根目录 HTML 入口文件中提前设置： -->
   <script>
     window.__backend_api_url = "https://api.yourdomain.com";
   </script>
   ```

#### TypeScript 声明的作用

```typescript
// vite-env.d.ts
declare const __APP_VERSION__: string;
```

- `declare const APP_VERSION: string` 这行代码就是告诉 TypeScript：

- "别报错！我知道这个变量在其他地方定义好了，它就是字符串类型"

- 没有这行声明，TypeScript 会认为 `APP_VERSION` 是个未定义的变量而报错。

---

### plugins

#### 类型定义

(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[] 表示数组元素可以是：

- 单个插件实例（Plugin）
- 插件数组（Plugin[]）
- 返回插件实例或数组的 Promise（Promise<...>）‌

#### 数组处理逻辑

- ‌ 扁平化（flatten）‌：嵌套的插件数组会被展开为一维数组。

  ```javascript
  [pluginA, [pluginB, pluginC]];
  // 实际生效为 [pluginA, pluginB, pluginC]
  ```

- 忽略假值（Falsy）‌：null、undefined 或空数组等会被跳过，便于条件启用插件：

  ```javascript
  plugins: [somePlugin, null, enableDebug ? debugPlugin : []];
  // 实际生效为 [somePlugin, debugPlugin]
  ```

#### 插件执行顺序

默认按数组顺序执行，但可通过 `enforce` 修饰符强制优先级：

- pre：在 Vite 核心插件前执行
- post：在构建阶段后执行 ‌

```javascript
plugins: [
  {
    ...pluginA,
    enforce: "pre", // 在 Vite 核心插件之前执行
  },
  vitePlugin, // Vite 内置插件
  {
    ...pluginB,
    enforce: "post", // 在构建阶段后执行
  },
];
```

#### 实际配置示例

```javascript
import { defineConfig } from "vite";
import legacy from "@vitejs/plugin-legacy";

export default defineConfig({
  plugins: [
    // 单个插件
    legacy({ targets: ["defaults"] }),

    // 插件数组（会被扁平化）
    [require("@vite/plugin-react"), require("@vite/plugin-typescript")],

    // 动态插件（通过 Promise）
    import("./dynamic-plugin").then((plugin) => plugin.default),
  ],
});
```

#### 注意事项

- 优先使用 Vite 内置功能，避免不必要的插件 ‌
- 兼容性：部分 Rollup 插件需通过 enforce 调整顺序。

#### [必看官方插件 API](https://cn.vitejs.dev/guide/api-plugin.html) 后续需要单独整理出一个文件夹

#### [必看 Rollup 插件文档](https://cn.rollupjs.org/plugin-development/) 后续需要单独整理出一个文件夹

---
