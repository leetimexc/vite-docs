对 Vite 官方文档 [共享选项](https://cn.vitejs.dev/config/shared-options.html) 的理解。

### root

- 类型： string
- 默认： process.cwd()

用于指定项目的根目录位置，也就是 index.html 文件所在的文件夹。

**核心原因 ‌：** Vite 需要找到 index.html 作为应用的入口文件，才能正确地将 Vue 组件渲染到页面上。

**‌ 具体流程 ‌：**

1. ‌Vite 启动 ‌ 时，首先要找到 index.html
2. 在 index.html 中 ‌，通常有这样的代码：

   ```html
   <div id="app"></div>
   <script type="module" src="/src/main.js"></script>
   ```

3. **通过这个入口**‌ ，Vite 才能加载 Vue 应用，并把组件渲染到指定的 DOM 元素中。

#### ‌ 为什么需要 root 配置 ‌：

- 如果项目结构特殊（比如配置文件不在根目录）
- 或者有多个项目共用配置
- Vite 就不知道去哪里找这个 index.html
- 设置 root 就是明确告诉 Vite 入口文件的位置

**简单说：root 配置就是给 Vite 一个明确的"地图"，让它能找到渲染 Vue 组件的"画布"（HTML 文件）**

---

### base

- 类型： string
- 默认： /

base 配置其实就是**设置你的网站在服务器上的"存放位置"‌**

#### 简单理解：

- 如果你的网站直接放在服务器根目录，base 就是 /
- 如果你的网站放在某个子文件夹里，比如 admin 文件夹，base 就是 /admin/

#### ‌ 具体场景举例：‌

1. 默认情况 ‌（base = "/"）

- 网站地址：https://example.com
- 资源路径：https://example.com/js/app.js

2. 子目录部署 ‌（base = "/admin/"）

- 网站地址：https://example.com/admin/
- 资源路径：https://example.com/admin/js/app.js

#### ‌ 为什么需要这个配置？

当你的项目部署到非根目录时，如果不设置正确的 base：

- 图片、CSS、JS 等资源加载失败
- 路由跳转出错
- 页面显示空白（白屏）

#### 合法的 base 值类型：‌

- /foo/ - 部署到 foo 子目录
- https://bar.com/foo/ - 完整 URL（开发时域名部分忽略）
- ./ 或空字符串 - 用于嵌入式开发

#### 实际应用：

比如你的项目要部署到公司官网的 `/vite-project/` 路径下，就在 vite.config.ts 中配置：

```javascript
export default defineConfig({
  base: "/vite-project/",
});
```

这样打包后所有资源路径都会自动加上 `/vite-project/` 前缀，确保在生产环境正常访问

---

### mode

- 类型： string
- 默认： 'development' 用于开发，'production' 用于构建

#### Vite 会根据你设置的 mode 值，自动切换不同的工作模式，实现开发和生产环境的差异化处理。

**开发模式 (development)‌**

- 构建工具:（快速编译）
- 浏览器:（详细的错误提示）
- 代码:（代码不压缩，可读性强）

**生产模式 (production)‌**

- 构建工具:（代码压缩和优化）
- 浏览器: （简洁的错误信息）
- 代码:（代码被压缩，体积小，加载快）

#### 那如果我配置了自定义 mode vite 怎么会判断是开发 还是生产？

Vite 通过以下几种方式来判断当前是开发环境还是生产环境：

1. 环境判断机制

   - import.meta.env.MODE 和 process.env.NODE_ENV 这两个环境变量来识别当前运行模式
   - 无论你设置什么自定义 mode，只要 NODE_ENV 不是 'production'，Vite 就会将其视为开发环境

2. 默认行为规则
   - 运行 vite 命令时默认使用 'development' 模式
   - 运行 vite build 命令时默认使用 'production' 模式
3. 环境变量优先级

   1. 首先加载 .env 文件中的全局配置
   2. 然后根据当前 mode 加载对应的环境文件（如 .env.development、.env.production）
   3. 最后应用命令行指定的 mode

4. 实际应用示例

   ```json
   {
     "scripts": {
       "dev": "vite --mode development",
       "test": "vite --mode test"
     }
   }
   ```

5. 关键判断标准

   - 最核心的判断依据是 NODE_ENV 的值
   - 当 NODE_ENV 明确设置为 'production' 时，Vite 才会启用生产环境的优化配置

6. 最佳实践建议

   为了确保环境判断的准确性，建议：

   - 在 .env.development 中设置 NODE_ENV = 'development'
   - 在 .env.production 中设置 NODE_ENV = 'production'
   - 在 package.json 中明确指定各命令对应的 mode

**Vite 主要看 NODE_ENV 这个关键变量来判断环境，自定义 mode 主要用于区分不同的业务场景，而不影响核心的环境判断逻辑**

#### 在实际项目中怎么用？

1. 在配置文件里设置 (vite.config.js)

   ```javascript
   export default {
     // 当运行 `vite` 命令时，默认就是这个模式
     mode: "development",
   };
   ```

2. 在命令行里覆盖

   ```bash
   # 用开发模式启动
   vite --mode development

   # 用生产模式打包
   vite build --mode production
   ```

#### 为什么这个功能很重要？

因为它让你可以写“智能代码”，同一份代码在不同环境下表现不同：

```javascript
// 这段代码能自动识别当前环境
if (import.meta.env.MODE === "development") {
  // 只有开发时才启用调试工具
  console.log("这是详细的调试信息");
} else {
  // 生产环境就保持简洁
  console.log("系统提示");
}
```

#### NODE_ENV 和 mode 的区别？

- NODE_ENV 确实是传统的环境变量，用来区分开发和生产环境
- mode 是 Vite 自定义的，用于区分不同的业务场景，而不影响核心的环境判断逻辑

#### NODE_ENV 就像天气 ‌

- 只有两种：晴天（production）或阴天（development）
- 影响全局，比较粗糙

#### Vite 的 mode 就像具体的活动安排 ‌

- 可以有更多选择：开发、测试、预发布、生产等
- 更精细，可以针对不同场景做特定配置

#### ‌ 实际关系：‌

- Vite 内部还是会看 NODE_ENV 来做基础判断
- 但 mode 让你可以创建更多"子环境"

**比如你可以在开发阶段设置不同的模式：**

```bash
# 本地开发
vite --mode development

# 测试环境
vite --mode test

# 演示环境
vite --mode demo
```

**然后在代码中根据具体模式做更精细的控制：**

```javascript
if (import.meta.env.MODE === "test") {
  // 测试环境的特殊逻辑
  mockAPI(); // 使用模拟数据
}
```

所以 **mode** 是对 **NODE_ENV** 的扩展和补充，让你有更灵活的环境管理能力。

---

### define

**define 就是一个"查找替换"工具 ‌，** 它能在你打包代码时自动把特定的变量名换成实际的值

#### 它具体做什么？

想象你在写代码时经常要用到应用版本号，比如：

```javascript
// 如果没有 define，你需要手动写版本号，再这些地方都写一遍
console.log("场景1-当前版本：" + __APP_VERSION__);
console.log("场景2-当前版本：" + __APP_VERSION__);
console.log("场景3-当前版本：" + __APP_VERSION__);
console.log("场景4-当前版本：" + __APP_VERSION__);
console.log("场景5-当前版本：" + __APP_VERSION__);
console.log("场景6-当前版本：" + __APP_VERSION__);
console.log("场景7-当前版本：" + __APP_VERSION__);
console.log("场景8-当前版本：" + __APP_VERSION__);
```

有了 define，你只需要在配置里定义一次：

```javascript
// 打包时，Vite 会自动把代码里所有的 __APP_VERSION__ 都换成 "v1.0.0"
export default defineConfig({
  define: {
    __APP_VERSION__: "1.0.0",
  },
});
```

#### 两种常见用法

1. ‌ 直接替换成固定值

   ```javascript
   // 这样代码中的 __APP_VERSION__ 就变成了硬编码的字符串 "v1.0.0"
   // 静态替换，需要重新构建项目
   __APP_VERSION__: JSON.stringify("v1.0.0");
   ```

2. 替换成运行时变量

   ```javascript
   // 这样代码会去读取浏览器中 window 对象上的值
   // 动态替换，不需要重新构建项目，只需要更新 HTML 中的配置值即可动态调整 API 地址
   __API_URL__: "window.__backend_api_url";
   ```

   ```html
   <!-- 在根目录 HTML 入口文件中提前设置： -->
   <script>
     window.__backend_api_url = "https://api.yourdomain.com";
   </script>
   ```

#### TypeScript 声明的作用

```typescript
// vite-env.d.ts
declare const __APP_VERSION__: string;
```

- `declare const APP_VERSION: string` 这行代码就是告诉 TypeScript：

- "别报错！我知道这个变量在其他地方定义好了，它就是字符串类型"

- 没有这行声明，TypeScript 会认为 `APP_VERSION` 是个未定义的变量而报错。

---

### plugins

#### 类型定义

(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[] 表示数组元素可以是：

- 单个插件实例（Plugin）
- 插件数组（Plugin[]）
- 返回插件实例或数组的 Promise（Promise<...>）‌

#### 数组处理逻辑

- ‌ 扁平化（flatten）‌：嵌套的插件数组会被展开为一维数组。

  ```javascript
  [pluginA, [pluginB, pluginC]];
  // 实际生效为 [pluginA, pluginB, pluginC]
  ```

- 忽略假值（Falsy）‌：null、undefined 或空数组等会被跳过，便于条件启用插件：

  ```javascript
  plugins: [somePlugin, null, enableDebug ? debugPlugin : []];
  // 实际生效为 [somePlugin, debugPlugin]
  ```

#### 插件执行顺序

默认按数组顺序执行，但可通过 `enforce` 修饰符强制优先级：

- pre：在 Vite 核心插件前执行
- post：在构建阶段后执行 ‌

```javascript
plugins: [
  {
    ...pluginA,
    enforce: "pre", // 在 Vite 核心插件之前执行
  },
  vitePlugin, // Vite 内置插件
  {
    ...pluginB,
    enforce: "post", // 在构建阶段后执行
  },
];
```

#### 实际配置示例

```javascript
import { defineConfig } from "vite";
import legacy from "@vitejs/plugin-legacy";

export default defineConfig({
  plugins: [
    // 单个插件
    legacy({ targets: ["defaults"] }),

    // 插件数组（会被扁平化）
    [require("@vite/plugin-react"), require("@vite/plugin-typescript")],

    // 动态插件（通过 Promise）
    import("./dynamic-plugin").then((plugin) => plugin.default),
  ],
});
```

#### 注意事项

- 优先使用 Vite 内置功能，避免不必要的插件 ‌
- 兼容性：部分 Rollup 插件需通过 enforce 调整顺序。

#### [必看官方插件 API](https://cn.vitejs.dev/guide/api-plugin.html) 后续需要单独整理出一个文件夹

#### [必看 Rollup 插件文档](https://cn.rollupjs.org/plugin-development/) 后续需要单独整理出一个文件夹

---

### publicDir

- 类型： string | false
- 默认： "public"

#### 通俗理解

你可以把 `publicDir` 看作一个"公共仓库"：

- ‌**开发时 ‌：** 仓库里的物品（文件）可以直接按名字领取（访问）
- **构建时 ‌：** 仓库里的所有物品会原封不动地搬到新家（输出目录）

#### 配置选项

- **默认值 ‌：** `"public"` - 使用项目根目录下的 `public` 文件夹作为静态资源目录
- **自定义路径 ‌：** 可以设置为其他路径，如 `'assets'`
- **关闭功能 ‌：** 设置为 `false` 时，将禁用静态资源服务

#### 使用场景

1. **放不需要处理的静态资源 ‌**

   - 网站图标（favicon.ico）
   - robots.txt 文件
   - 不希望被哈希命名的文件

2. **资源引用方式 ‌：**

   - 开发环境：`![](/1.jpg)`
   - 构建后：文件保持原样复制到输出目录

#### 注意事项

- public 目录下的文件不会被 Vite 处理或压缩
- 如果项目部署在子路径下，需要配置 `base` 选项
- 使用动态 URL 时，可以通过 `import.meta.env.BASE_URL` 获取基础路径

通过合理配置 `publicDir`，可以方便地管理那些不需要构建处理的静态资源文件。

---

### cacheDir

- 类型： string
- 默认： "node_modules/.vite"

Vite 用来存放各种缓存文件的目录，默认位置在 `node_modules/.vite`。可以把它想象成 Vite 的"临时笔记本"或"草稿箱"。

#### 通俗理解

- **缓存目录 ‌：** Vite 工作时会把一些中间结果（比如转换后的依赖包）存起来，下次就不用重新处理了。
- ‌**性能加速 ‌：** 就像浏览器缓存网页一样，有了缓存，Vite 启动和热更新会快很多

#### 为什么需要缓存目录

1. ‌ **加快启动速度 ‌：**

   Vite 首次启动时会预构建依赖项，将这些依赖从 CommonJS 转换为 ESM 格式，缓存起来后后续启动就直接使用

2. **‌ 优化热更新 ‌：**

   开发时修改代码，Vite 只需要重新构建改动的部分

3. **‌ 减少重复工作 ‌：**

   避免每次都重新处理相同的依赖项

#### 什么是 CommonJS

该规范主要为非浏览器环境设计，特别是服务器端应用程序

**核心机制：**

- **导入模块:** 通过 require()函数**同步**加载模块
- **导出模块:** 使用 module.exports 导出功能接口

**每个文件被视为一个独立模块，具有封闭的作用域，模块内的变量、函数和类对其他文件不可见。**

**module.exports**

module 变量代表当前模块，其 exports 属性是对外的接口。

**缺点：**

- **同步加载**：CommonJS 的 require() 是同步的，这可能导致阻塞，影响性能
- **不适合浏览器**：浏览器环境不支持 CommonJS，需要转换为 ESM 格式
- **不支持动态加载**：CommonJS 的 require() 只能同步加载模块，不能动态加载模块
- **打包体积**： 该规范在设计时并未充分考虑包大小控制，这可能影响最终的打包体积

随着 ES6 模块系统的出现，JavaScript 拥有了原生的模块化支持，但 CommonJS 仍在 Node.js 等服务器端环境中广泛使用

#### 什么是 ESM 格式

ESM 是 ECMAScript Modules 的缩写，它是 JavaScript 语言的官方模块化方案

作为 ES6 (ECMAScript 2015) 引入的标准，它旨在统一浏览器和服务器端的模块系统，解决此前社区方案（如 CommonJS、AMD）导致的生态碎片化问题

- **核心语法与特点**

  ESM 使用 `import` 和 `export` 关键字进行模块的导入与导出

  它支持两种主要的导出方式：‌ `命名导出` ‌（允许一个模块导出多个值）和 ‌ `默认导出` ‌（每个模块只能有一个）

#### ESM 和 CommonJS 的区别

1. **使用环境对比**

- ‌**CommonJS‌**
  - 主要在 Node.js 服务器端环境中使用，采用同步加载机制，适用于本地文件系统操作
  - 其设计目标是为非浏览器环境提供标准化库支持，涵盖文件系统、I/O 流等基础功能
- ‌**ESM‌**
  - ECMAScript 标准模块系统，具有跨端特性，既能在现代浏览器中运行，也能在 Node.js 环境中使用
  - ESM 支持异步加载，更适合网络环境

2. **如果 ESM 可以跨端 那么 node 为什么不都用 ESM，还继续使用 CommonJS 呢？**

   虽然 ESM 可以跨端，但 Node.js 没有完全放弃 CommonJS 主要有以下原因：

   - ‌ **历史兼容性：** Node.js 生态系统中有大量现有包采用 CommonJS 格式，完全迁移需要时间。在 Node.js 13.2.0 之前，主要使用 CommonJS 模式
   - ‌ **文件扩展名区分：** Node.js 通过文件扩展名来区分模块类型 - .mjs 文件使用 ESM 规范，.cjs 文件使用 CommonJS 规范，而 .js 文件默认采用 CommonJS 标准

   - ‌ **加载机制差异：** CommonJS 是同步加载，在服务器端由于模块存储在本地磁盘，加载速度较快；而 ESM 设计为可以异步加载

3. **与 CommonJS 的关键差异**

   在加载机制上，ESM 是 ‌ `编译时静态加载` ‌ 的，这意味着模块的依赖关系在代码执行前就已确定，这使得打包工具可以进行静态分析，实现如 `Tree Shaking`（消除无用代码）等优化

   ESM 输出的是`值的引用` ‌，所有导入该值的模块都共享同一份内存地址。

#### 主要使用场景

1. **多项目工作区 ‌：**

   在多项目工作区中，可能 ‌ 共用同一个 node_modules 目录，在 Bun 或 pnpm 工作区中，可以为不同项目设置独立的缓存路径，避免冲突

   ```javascript
      // 项目A的vite.config.js
      export default defineConfig({
        cacheDir: '../../node_modules/.vite-project-a'
      })

      // 项目B的vite.config.js
      export default defineConfig({
        cacheDir: '../../node_modules/.vite-project-b'
      })
   ```

2. **CI/CD 环境 ‌：**

   通过环境变量动态控制缓存目录，适应不同的构建环境

   ```yaml
   <!--通过设置不同的CACHE_DIR环境变量，就能让同一个构建脚本在不同环境中使用不同的缓存位置 -->
   build_job:
     cache:
       paths:
         - $CACHE_DIR/node_modules/
     script:
       - npm install
       - npm run build
   ```

   在 CI/CD 配置文件（如 GitLab CI 的`.gitlab-ci.yml`）中定义环境变量，这样可以在不同的构建环境中使用不同的缓存路径

3. **持久化缓存：**

   将缓存目录移到项目根目录下，避免因 `node_modules` 变动导致的缓存失效

4. ‌**缓存清理 ‌：**
   当遇到奇怪的构建问题时，可以通过 `--force` 选项或手动删除缓存目录来重新生成

#### 实际配置示例

```javascript
// vite.config.js
export default defineConfig({
  cacheDir: ".vite_cache", // 自定义缓存目录
});
```

简单来说，cacheDir 就是 Vite 的"记忆仓库"，记住之前做过的工作，避免重复劳动，从而让开发和构建过程更加高效。

---

### resolve.alias

- 类型：Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>

主要作用是为常用路径创建简短的别名，让代码导入更简洁清晰。

#### 为什么要用路径别名？

在大型项目中，你经常会看到这样的导入：

```javascript
import Button from "../../../components/Button";
import utils from "../../../../utils/helpers";
```

使用别名后，代码变得更简洁：

```javascript
import Button from "@components/Button";
import utils from "@utils/helpers";
```

#### 如何配置路径别名？

- 对象写法（最常用）

  ```javascript
  resolve: {
    alias: {
      '@': '/src',
      '@components': '/src/components',
      '@utils': '/src/utils'
    }
  }
  ```

- 数组写法（更灵活）

  ```javascript
  resolve: {
    alias: [
      { find: "@", replacement: "/src" },
      { find: /^@components\/(.*)/, replacement: "/src/components/$1" },
    ];
  }
  ```

#### 重要注意事项

**必须使用绝对路径**

配置别名时一定要用完整路径，不能使用相对路径

```javascript
// ‌正确做法：
'@': path.resolve(__dirname, 'src')

// ‌错误做法：
'@': './src'  // 这样会出问题！
```

#### 关于 SSR 的特殊说明

在服务端渲染（SSR）时，如果你配置了外部依赖的别名，可能需要为真实的 `node_modules` 包也配置别名。使用 `npm: ` 前缀可以让 Yarn 和 pnpm 正确处理这些依赖关系

---

### resolve.dedupe

用于解决依赖重复问题的配置选项，主要作用是强制让相同依赖的不同版本都指向同一个副本

#### 主要用途

‌ 解决依赖冲突问题 ‌：当你的项目中存在相同依赖的多个版本时，比如：

- 项目依赖 A 和 B，它们分别依赖了不同版本的 C
- 直接安装了相同依赖的多个版本
- 在 monorepo（多包仓库）项目中，不同包使用了相同依赖的不同版本

‌ 配置示例 ‌：

```javascript
// vite.config.js
export default {
  resolve: {
    dedupe: ["lodash", "react", "vue"],
  },
};
```

#### 实际效果

- **配置前 ‌：**

  项目中可能同时存在 `lodash@4.17.15` 和 `lodash@4.17.21` 两个版本，导致打包体积增大

- **配置后 ‌：**

  Vite 会强制所有对 `lodash` 的引用都指向同一个版本（通常是项目根目录下的版本），减小最终构建产物体积

#### 关于 SSR + ESM 的特殊说明

在服务端渲染（SSR）场景下，当配置 build.rollupOptions.output 为 ESM（ES Module）格式时，依赖去重功能可能无法正常工作。

‌ **解决方案 ‌：**

可以暂时使用 CJS（CommonJS）构建输出，等待 ESM 在插件中获得更好的模块加载支持。

---
