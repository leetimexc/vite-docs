对官方文档 [配置 Vite](https://cn.vitejs.dev/config/) 的理解。

### vite 到底是什么？

**‌ 一个简单的比喻：把 Vite 想象成一个“智能厨房”‌**

- **你的项目（比如一个 Vue 网站）‌：** 就像你想做的一道菜。
- **源代码（.vue, .js 文件）‌：** 就像生的食材（蔬菜、肉）。
- ‌**Vite‌：** 就是这个厨房本身，负责把生的食材加工成可以吃的饭菜。
- ‌**vite.config.js‌：** 就是这张“厨房使用说明书”，告诉厨房：

  - 火要开多大？（服务器端口）
  - 菜要切成什么形状？（路径别名）
  - 要用哪些特殊的厨具？（插件）

### 直接创建一个 vite.config.js 然后使用 vite 能跑起来吗？

不行，需要项目的基础结构和依赖，直接新建一个 vite.config.js 但厨房里没有食材（你的项目文件），也没有告诉厨房要做什么菜（没有入口文件），Vite 当然不知道要做什么，也就跑不起来了。

### 如何创建一个 vite 环境？

#### 环境准备

首先确保你的系统已安装 Node.js，推荐使用 18.0.0 或以上的 LTS 版本

#### 创建 Vite 项目

```bash
# 使用 npm
npm create vite@latest
```

#### 项目结构

```text
my-vite-project/
├── public/           # 静态资源
├── src/
│   ├── assets/       # 图片/字体等资源
│   ├── components/  # 公共组件
│   ├── App.vue      # 根组件
│   └── main.js      # 入口文件
├── vite.config.js    # Vite 配置文件
└── package.json     # 项目配置和依赖管理
```

---

### vite.config.js 配置示例

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { fileURLToPath, URL } from 'node:url'

// https://vitejs.dev/config/
export default defineConfig({
  // 插件配置
  plugins: [vue()],

  // 开发服务器配置
  server: {
    port: 3000, // 端口号
    host: '0.0.0.0', // 允许局域网访问
    open: true, // 自动打开浏览器
    proxy: {
      // 代理配置，解决跨域问题
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },

  // 构建配置
  build: {
    outDir: 'dist', // 输出目录
    assetsDir: 'assets', // 静态资源目录
    sourcemap: true, // 生成 sourcemap
    minify: 'terser', // 代码压缩工具
    rollupOptions: {
      // 分包配置
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router'],
          utils: ['lodash', 'axios'],
        },
      },
    },
  },

  // 路径别名配置
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
      '@components': fileURLToPath(
        new URL('./src/components', import.meta.url)
      ),
      '@views': fileURLToPath(new URL('./src/views', import.meta.url)),
    },
  },

  // CSS 预处理器配置
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`,
      },
    },
  },

  // 环境变量配置
  define: {
    'process.env': process.env,
  },

  // 基础路径（部署到子目录时使用）
  base: './',

  // 依赖优化选项
  optimizeDeps: {
    include: ['lodash', 'axios'],
  },
})
```

### 如何在编写 vite.config.js 文件时，让你的代码编辑器（如 VS Code）给你提供“代码补全”和“智能提示”的功能？

#### 1.使用 JSDoc 注释（传统方法）

```javascript
/** @type {import('vite').UserConfig} */
export default {
  // 当你在这里输入时，编辑器会提示你 port, proxy, plugins 等选项
}
```

- 通俗解释 ‌：
  - /\*_ ... _/ 是一个特殊的注释
  - 这行注释是在告诉你的代码编辑器：“嘿，我后面这个对象里的所有配置，都要按照 Vite 官方定义的 UserConfig 类型来检查。”
  - 这样，当你输入 ser 时，编辑器会自动提示 server，然后输入 port 时，它会知道这里应该填一个数字。
- ‌ **特点 ‌：** 这种方法不需要 import 语句，是纯 JavaScript 的写法。

#### 2.使用 defineConfig 工具函数（推荐方法）

```
import { defineConfig } from 'vite'

export default defineConfig({
  // 在这里写配置，同样有智能提示
})
```

- ‌ 通俗解释 ‌：
  - defineConfig 是 Vite 提供的一个“智能包装盒”。
  - 你把你的配置对象放进这个盒子里，这个盒子自然就带有了类型信息。
  - 这是**最常用、最推荐**的方法，因为它最简洁。

#### 3.（针对 TypeScript 配置文件）

如果你用 vite.config.ts（TypeScript 文件），还有另一种写法：

```typescript
import type { UserConfig } from 'vite'

export default {
  // 你的配置
} satisfies UserConfig
```

- ‌ 通俗解释 ‌：
  - satisfies 是 TypeScript 中的一个运算符，意思是“满足”。
  - 这行代码是在说：“我导出的这个对象，它满足 UserConfig 类型的所有要求。”
  - 它会让 TypeScript 编译器检查你的配置是否正确，同时保持你写的对象结构。

#### 总结与选择

<!-- 表格 -->

| 方法         | 适用场景                          | 优点                 | 缺点               |
| ------------ | --------------------------------- | -------------------- | ------------------ |
| JSDoc 注释   | 纯 JavaScript 项目，不想用 import | 无额外依赖           | 写法稍显繁琐       |
| defineConfig | 绝大多数情况（最推荐）            | 简洁直观，类型提示好 | 需要写 import 语句 |
| satisfies    | TypeScript 项目                   | 类型检查严格         | 只能用于 .ts 文件  |

---

### 情景配置

#### 核心概念：函数式配置

```javascript
export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
  // 这里可以根据不同情况返回不同的配置
})
```

这个函数接收一个参数对象，里面有 4 个重要的信息：

- **command:** 告诉你当前是开发还是构建
  - `'serve'` = 开发模式（运行 vite 或 vite dev）
  - `'build'` = 构建模式（运行 vite build）
- **mode:** 环境模式，通常来自 `--mode` 参数
  - `'development'` = 开发环境
  - `'production'` = 生产环境
- **isSsrBuild:** 是否是服务端渲染构建
- **isPreview:** 是否是预览模式

#### 把 Vite 想象成一个"厨师"

**‌command - 厨师在做什么菜？‌**

- 这个值是 **Vite 自动给你的**，你不需要设置

  - `'serve'` = 厨师正在厨房现场做菜给你吃（开发模式）
  - `'build'` = 厨师把菜做好打包成外卖（构建模式）

  **简单说：当你运行不同命令时，Vite 自动告诉你现在是什么模式**

  ```javascript
  export default defineConfig(({ command }) => {
    console.log('当前厨师在io', command)
    // 运行 `vite` 或 `vite dev` → 输出 "serve"
    // 运行 `vite build` → 输出 "build"
  })
  ```

**mode - 这道菜的口味**

- mode 是你自己可以设置的 ‌，就像点菜时说"要辣的"还是"不辣的"：

  ```javascript
  // 在 package.json 中
  {
    "scripts": {
      "dev": "vite", // 默认 mode = 'development'
      "build": "vite build", // 默认 mode = 'production'
      "build:test": "vite build --mode test" // 自定义 mode
    }
  }
  ```

  **实际例子：**

  ```javascript
  export default defineConfig(({ command, mode }) => {
    console.log('厨师在：', command, '，口味是：', mode)

    // 根据不同的情况返回不同配置
    if (command === 'serve') {
      return {
        // 开发环境配置：快速上菜，方便调整
        server: { port: 3000 },
      }
    } else {
      // command === 'build'
      if (mode === 'development') {
        return {
          // 测试环境构建：保留调试信息
          build: { sourcemap: true },
        }
      } else {
        return {
          // 生产环境构建：极致优化
          build: { minify: true },
        }
      }
    }
  })
  ```

**总结一下：**

- command：Vite 自动告诉你 → "我在开发" 或 "我在构建"
- mode：你可以自己设置 → "要开发口味" 或 "要生产口味"

**简单记法：**

- command = 做什么（开发/构建）
- mode = 给谁吃（开发环境/生产环境）

**command 是 Vite 告诉你的，mode 是你告诉 Vite 的**

### 实际应用场景举例

- 场景一：开发和生产环境使用不同的 API 地址

  ```javascript
  export default defineConfig(({ command }) => {
  const baseConfig = {
    plugins: [vue()],
    resolve: {
      alias: {
        '@': '/src'
      }
    }
  }

  if (command === 'serve') {
    // 开发环境：使用本地API
    return {
      ...baseConfig,
      server: {
        proxy: {
          '/api': 'http://localhost:3000'
      }
    }
  } else {
    // 生产环境：使用线上API
    return {
      ...baseConfig,
      define: {
        'process.env.API_BASE': '"https://api.myapp.com"'
    }
  }
  })
  ```

- 场景二：只在构建时启用代码压缩
  ```javascript
  export default defineConfig(({ command }) => {
    if (command === 'serve') {
      return {
        // 开发环境：不压缩，方便调试
        plugins: [vue()],
      }
    } else {
      return {
        // 生产环境：启用压缩，减小文件体积
        plugins: [vue()],
        build: {
          minify: 'terser',
        },
      }
    }
  })
  ```
- 关于 isSsrBuild 和 isPreview 的注意事项

  - 文档提醒我们：‌ 有些工具可能无法识别这些新参数 ‌，所以它们可能会是 undefined。
  - ‌ 安全写法：

    ```javascript
    export default defineConfig(({ command, isSsrBuild, isPreview }) => {
      if (command === 'serve') {
        // 开发服务器配置
      } else if (isSsrBuild === true) {
        // 服务端渲染构建配置
      } else if (isPreview === true) {
        // 预览模式配置
      } else {
        // 普通的客户端构建配置
      }
    })
    ```

#### 总结

**简单来说，“情景配置”就是让你的配置文件能够“看情况办事”:**

- **开发时：** 配置调试友好的选项（如 sourcemap、代理）
- **构建时：** 配置性能优化的选项（如压缩、代码分割）
- **不同环境：** 配置不同的 API 地址、资源路径等

**什么时候需要用这种函数式配置？**

- 开发和生产环境需要不同配置时
- 客户端和服务端渲染需要不同配置时
- 需要根据环境变量动态调整配置时

---

### 异步配置

defineConfig 可以传递一个异步函数

#### 什么时候需要用异步配置？

- **需要从 API 获取配置信息时**
- **需要动态导入插件时**
- **需要读取异步文件时**
- **需要等待用户输入时**

#### 核心要点

- **defineConfig 是智能包装器：** 它能识别同步和异步函数
- **async 函数自动返回 Promise**
- **Vite 内部会处理这个 Promise，** 等待它解析为最终的配置对象

简单来说：‌ 不是你手动包装 Promise，而是 async 函数天然返回 Promise，Vite 知道如何等待它完成

---

### 在配置中使用环境变量

配置文件中使用环境变量和在代码中使用环境变量是不同的

- **写代码时**（如 main.js, App.vue）→ 用 import.meta.env.VITE_XXX
- **写配置时**（如 vite.config.js）→ 用 loadEnv() 手动加载 + env.VITE_XXX

#### 为什么这么麻烦？

**时间线问题：**

1. **vite.config.js 运行时：** 项目自己的 .env 文件还没被读取
2. **你的源代码运行时：** .env 文件已经被 Vite 自动加载了

#### 实际例子对比：

- 在 Vue/JS 代码中（这样用）：

  ```javascript
  const value = import.meta.env.VITE_XXX
  ```

- 在 vite.config.js 中（需要这样用）：

  ```javascript
  import { defineConfig, loadEnv } from 'vite'

  export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, process.cwd(), '')
    // 然后使用 env.VITE_XXX 来获取值
  })
  ```

#### process.cwd 是什么

process.cwd() 是 Node.js 中的一个方法，用于获取**当前工作目录**的绝对路径，它返回的是启动 Node.js 进程时所在的目录路径

#### process.env 是什么

process.env 是 Node.js 中的一个全局对象，它包含了当前进程的所有环境变量。

#### loadEnv 是什么

loadEnv 是 Vite 提供的一个函数，用于加载环境变量。

#### 总结：

**‌process.cwd()‌** = "现在我在哪个文件夹？"

- 比如你在 C:\projects\my-app 运行命令
- process.cwd() 就返回 C:\projects\my-app

**‌process.env‌** = "电脑的环境设置"

- 比如电脑用户名、系统路径等

**‌loadEnv()‌** = "去.env 文件里拿配置"

- 比如从 .env 文件里拿 VITE_API_URL

---

### 在 VS Code 上调试配置文件

后面补充
