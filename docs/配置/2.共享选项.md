对 Vite 官方文档 [共享选项](https://cn.vitejs.dev/config/shared-options.html) 的理解。

### root

- 类型： string
- 默认： process.cwd()

用于指定项目的根目录位置，也就是 index.html 文件所在的文件夹。

**核心原因 ‌：** Vite 需要找到 index.html 作为应用的入口文件，才能正确地将 Vue 组件渲染到页面上。

**‌ 具体流程 ‌：**

1. ‌Vite 启动 ‌ 时，首先要找到 index.html
2. 在 index.html 中 ‌，通常有这样的代码：

   ```html
   <div id="app"></div>
   <script type="module" src="/src/main.js"></script>
   ```

3. **通过这个入口**‌ ，Vite 才能加载 Vue 应用，并把组件渲染到指定的 DOM 元素中。

#### ‌ 为什么需要 root 配置 ‌：

- 如果项目结构特殊（比如配置文件不在根目录）
- 或者有多个项目共用配置
- Vite 就不知道去哪里找这个 index.html
- 设置 root 就是明确告诉 Vite 入口文件的位置

**简单说：root 配置就是给 Vite 一个明确的"地图"，让它能找到渲染 Vue 组件的"画布"（HTML 文件）**

---

### base

- 类型： string
- 默认： /

base 配置其实就是**设置你的网站在服务器上的"存放位置"‌**

#### 简单理解：

- 如果你的网站直接放在服务器根目录，base 就是 /
- 如果你的网站放在某个子文件夹里，比如 admin 文件夹，base 就是 /admin/

#### ‌ 具体场景举例：‌

1. 默认情况 ‌（base = "/"）

- 网站地址：https://example.com
- 资源路径：https://example.com/js/app.js

2. 子目录部署 ‌（base = "/admin/"）

- 网站地址：https://example.com/admin/
- 资源路径：https://example.com/admin/js/app.js

#### ‌ 为什么需要这个配置？

当你的项目部署到非根目录时，如果不设置正确的 base：

- 图片、CSS、JS 等资源加载失败
- 路由跳转出错
- 页面显示空白（白屏）

#### 合法的 base 值类型：‌

- /foo/ - 部署到 foo 子目录
- https://bar.com/foo/ - 完整 URL（开发时域名部分忽略）
- ./ 或空字符串 - 用于嵌入式开发

#### 实际应用：

比如你的项目要部署到公司官网的 `/vite-project/` 路径下，就在 vite.config.ts 中配置：

```javascript
export default defineConfig({
  base: "/vite-project/",
});
```

这样打包后所有资源路径都会自动加上 `/vite-project/` 前缀，确保在生产环境正常访问

---

### mode

- 类型： string
- 默认： 'development' 用于开发，'production' 用于构建

#### Vite 会根据你设置的 mode 值，自动切换不同的工作模式，实现开发和生产环境的差异化处理。

**开发模式 (development)‌**

- 构建工具:（快速编译）
- 浏览器:（详细的错误提示）
- 代码:（代码不压缩，可读性强）

**生产模式 (production)‌**

- 构建工具:（代码压缩和优化）
- 浏览器: （简洁的错误信息）
- 代码:（代码被压缩，体积小，加载快）

#### 那如果我配置了自定义 mode vite 怎么会判断是开发 还是生产？

Vite 通过以下几种方式来判断当前是开发环境还是生产环境：

1. 环境判断机制

   - import.meta.env.MODE 和 process.env.NODE_ENV 这两个环境变量来识别当前运行模式
   - 无论你设置什么自定义 mode，只要 NODE_ENV 不是 'production'，Vite 就会将其视为开发环境

2. 默认行为规则
   - 运行 vite 命令时默认使用 'development' 模式
   - 运行 vite build 命令时默认使用 'production' 模式
3. 环境变量优先级

   1. 首先加载 .env 文件中的全局配置
   2. 然后根据当前 mode 加载对应的环境文件（如 .env.development、.env.production）
   3. 最后应用命令行指定的 mode

4. 实际应用示例

   ```json
   {
     "scripts": {
       "dev": "vite --mode development",
       "test": "vite --mode test"
     }
   }
   ```

5. 关键判断标准

   - 最核心的判断依据是 NODE_ENV 的值
   - 当 NODE_ENV 明确设置为 'production' 时，Vite 才会启用生产环境的优化配置

6. 最佳实践建议

   为了确保环境判断的准确性，建议：

   - 在 .env.development 中设置 NODE_ENV = 'development'
   - 在 .env.production 中设置 NODE_ENV = 'production'
   - 在 package.json 中明确指定各命令对应的 mode

**Vite 主要看 NODE_ENV 这个关键变量来判断环境，自定义 mode 主要用于区分不同的业务场景，而不影响核心的环境判断逻辑**

#### 在实际项目中怎么用？

1. 在配置文件里设置 (vite.config.js)

   ```javascript
   export default {
     // 当运行 `vite` 命令时，默认就是这个模式
     mode: "development",
   };
   ```

2. 在命令行里覆盖

   ```bash
   # 用开发模式启动
   vite --mode development

   # 用生产模式打包
   vite build --mode production
   ```

#### 为什么这个功能很重要？

因为它让你可以写“智能代码”，同一份代码在不同环境下表现不同：

```javascript
// 这段代码能自动识别当前环境
if (import.meta.env.MODE === "development") {
  // 只有开发时才启用调试工具
  console.log("这是详细的调试信息");
} else {
  // 生产环境就保持简洁
  console.log("系统提示");
}
```

#### NODE_ENV 和 mode 的区别？

- NODE_ENV 确实是传统的环境变量，用来区分开发和生产环境
- mode 是 Vite 自定义的，用于区分不同的业务场景，而不影响核心的环境判断逻辑

#### NODE_ENV 就像天气 ‌

- 只有两种：晴天（production）或阴天（development）
- 影响全局，比较粗糙

#### Vite 的 mode 就像具体的活动安排 ‌

- 可以有更多选择：开发、测试、预发布、生产等
- 更精细，可以针对不同场景做特定配置

#### ‌ 实际关系：‌

- Vite 内部还是会看 NODE_ENV 来做基础判断
- 但 mode 让你可以创建更多"子环境"

**比如你可以在开发阶段设置不同的模式：**

```bash
# 本地开发
vite --mode development

# 测试环境
vite --mode test

# 演示环境
vite --mode demo
```

**然后在代码中根据具体模式做更精细的控制：**

```javascript
if (import.meta.env.MODE === "test") {
  // 测试环境的特殊逻辑
  mockAPI(); // 使用模拟数据
}
```

所以 **mode** 是对 **NODE_ENV** 的扩展和补充，让你有更灵活的环境管理能力。

---

### define

**define 就是一个"查找替换"工具 ‌，** 它能在你打包代码时自动把特定的变量名换成实际的值

#### 它具体做什么？

想象你在写代码时经常要用到应用版本号，比如：

```javascript
// 如果没有 define，你需要手动写版本号，再这些地方都写一遍
console.log("场景1-当前版本：" + __APP_VERSION__);
console.log("场景2-当前版本：" + __APP_VERSION__);
console.log("场景3-当前版本：" + __APP_VERSION__);
console.log("场景4-当前版本：" + __APP_VERSION__);
console.log("场景5-当前版本：" + __APP_VERSION__);
console.log("场景6-当前版本：" + __APP_VERSION__);
console.log("场景7-当前版本：" + __APP_VERSION__);
console.log("场景8-当前版本：" + __APP_VERSION__);
```

有了 define，你只需要在配置里定义一次：

```javascript
// 打包时，Vite 会自动把代码里所有的 __APP_VERSION__ 都换成 "v1.0.0"
export default defineConfig({
  define: {
    __APP_VERSION__: "1.0.0",
  },
});
```

#### 两种常见用法

1. ‌ 直接替换成固定值

   ```javascript
   // 这样代码中的 __APP_VERSION__ 就变成了硬编码的字符串 "v1.0.0"
   // 静态替换，需要重新构建项目
   __APP_VERSION__: JSON.stringify("v1.0.0");
   ```

2. 替换成运行时变量

   ```javascript
   // 这样代码会去读取浏览器中 window 对象上的值
   // 动态替换，不需要重新构建项目，只需要更新 HTML 中的配置值即可动态调整 API 地址
   __API_URL__: "window.__backend_api_url";
   ```

   ```html
   <!-- 在根目录 HTML 入口文件中提前设置： -->
   <script>
     window.__backend_api_url = "https://api.yourdomain.com";
   </script>
   ```

#### TypeScript 声明的作用

```typescript
// vite-env.d.ts
declare const __APP_VERSION__: string;
```

- `declare const APP_VERSION: string` 这行代码就是告诉 TypeScript：

- "别报错！我知道这个变量在其他地方定义好了，它就是字符串类型"

- 没有这行声明，TypeScript 会认为 `APP_VERSION` 是个未定义的变量而报错。

---

### plugins

#### 类型定义

(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[] 表示数组元素可以是：

- 单个插件实例（Plugin）
- 插件数组（Plugin[]）
- 返回插件实例或数组的 Promise（Promise<...>）‌

#### 数组处理逻辑

- ‌ 扁平化（flatten）‌：嵌套的插件数组会被展开为一维数组。

  ```javascript
  [pluginA, [pluginB, pluginC]];
  // 实际生效为 [pluginA, pluginB, pluginC]
  ```

- 忽略假值（Falsy）‌：null、undefined 或空数组等会被跳过，便于条件启用插件：

  ```javascript
  plugins: [somePlugin, null, enableDebug ? debugPlugin : []];
  // 实际生效为 [somePlugin, debugPlugin]
  ```

#### 插件执行顺序

默认按数组顺序执行，但可通过 `enforce` 修饰符强制优先级：

- pre：在 Vite 核心插件前执行
- post：在构建阶段后执行 ‌

```javascript
plugins: [
  {
    ...pluginA,
    enforce: "pre", // 在 Vite 核心插件之前执行
  },
  vitePlugin, // Vite 内置插件
  {
    ...pluginB,
    enforce: "post", // 在构建阶段后执行
  },
];
```

#### 实际配置示例

```javascript
import { defineConfig } from "vite";
import legacy from "@vitejs/plugin-legacy";

export default defineConfig({
  plugins: [
    // 单个插件
    legacy({ targets: ["defaults"] }),

    // 插件数组（会被扁平化）
    [require("@vite/plugin-react"), require("@vite/plugin-typescript")],

    // 动态插件（通过 Promise）
    import("./dynamic-plugin").then((plugin) => plugin.default),
  ],
});
```

#### 注意事项

- 优先使用 Vite 内置功能，避免不必要的插件 ‌
- 兼容性：部分 Rollup 插件需通过 enforce 调整顺序。

#### [必看官方插件 API](https://cn.vitejs.dev/guide/api-plugin.html) 后续需要单独整理出一个文件夹

#### [必看 Rollup 插件文档](https://cn.rollupjs.org/plugin-development/) 后续需要单独整理出一个文件夹

---

### publicDir

- 类型： string | false
- 默认： "public"

#### 通俗理解

你可以把 `publicDir` 看作一个"公共仓库"：

- ‌**开发时 ‌：** 仓库里的物品（文件）可以直接按名字领取（访问）
- **构建时 ‌：** 仓库里的所有物品会原封不动地搬到新家（输出目录）

#### 配置选项

- **默认值 ‌：** `"public"` - 使用项目根目录下的 `public` 文件夹作为静态资源目录
- **自定义路径 ‌：** 可以设置为其他路径，如 `'assets'`
- **关闭功能 ‌：** 设置为 `false` 时，将禁用静态资源服务

#### 使用场景

1. **放不需要处理的静态资源 ‌**

   - 网站图标（favicon.ico）
   - robots.txt 文件
   - 不希望被哈希命名的文件

2. **资源引用方式 ‌：**

   - 开发环境：`![](/1.jpg)`
   - 构建后：文件保持原样复制到输出目录

#### 注意事项

- public 目录下的文件不会被 Vite 处理或压缩
- 如果项目部署在子路径下，需要配置 `base` 选项
- 使用动态 URL 时，可以通过 `import.meta.env.BASE_URL` 获取基础路径

通过合理配置 `publicDir`，可以方便地管理那些不需要构建处理的静态资源文件。

---

### cacheDir

- 类型： string
- 默认： "node_modules/.vite"

Vite 用来存放各种缓存文件的目录，默认位置在 `node_modules/.vite`。可以把它想象成 Vite 的"临时笔记本"或"草稿箱"。

#### 通俗理解

- **缓存目录 ‌：** Vite 工作时会把一些中间结果（比如转换后的依赖包）存起来，下次就不用重新处理了。
- ‌**性能加速 ‌：** 就像浏览器缓存网页一样，有了缓存，Vite 启动和热更新会快很多

#### 为什么需要缓存目录

1. ‌ **加快启动速度 ‌：**

   Vite 首次启动时会预构建依赖项，将这些依赖从 CommonJS 转换为 ESM 格式，缓存起来后后续启动就直接使用

2. **‌ 优化热更新 ‌：**

   开发时修改代码，Vite 只需要重新构建改动的部分

3. **‌ 减少重复工作 ‌：**

   避免每次都重新处理相同的依赖项

#### 什么是 CommonJS

该规范主要为非浏览器环境设计，特别是服务器端应用程序

**核心机制：**

- **导入模块:** 通过 require()函数**同步**加载模块
- **导出模块:** 使用 module.exports 导出功能接口

**每个文件被视为一个独立模块，具有封闭的作用域，模块内的变量、函数和类对其他文件不可见。**

**module.exports**

module 变量代表当前模块，其 exports 属性是对外的接口。

**缺点：**

- **同步加载**：CommonJS 的 require() 是同步的，这可能导致阻塞，影响性能
- **不适合浏览器**：浏览器环境不支持 CommonJS，需要转换为 ESM 格式
- **不支持动态加载**：CommonJS 的 require() 只能同步加载模块，不能动态加载模块
- **打包体积**： 该规范在设计时并未充分考虑包大小控制，这可能影响最终的打包体积

随着 ES6 模块系统的出现，JavaScript 拥有了原生的模块化支持，但 CommonJS 仍在 Node.js 等服务器端环境中广泛使用

#### 什么是 ESM 格式

ESM 是 ECMAScript Modules 的缩写，它是 JavaScript 语言的官方模块化方案

作为 ES6 (ECMAScript 2015) 引入的标准，它旨在统一浏览器和服务器端的模块系统，解决此前社区方案（如 CommonJS、AMD）导致的生态碎片化问题

- **核心语法与特点**

  ESM 使用 `import` 和 `export` 关键字进行模块的导入与导出

  它支持两种主要的导出方式：‌ `命名导出` ‌（允许一个模块导出多个值）和 ‌ `默认导出` ‌（每个模块只能有一个）

#### ESM 和 CommonJS 的区别

1. **使用环境对比**

- ‌**CommonJS‌**
  - 主要在 Node.js 服务器端环境中使用，采用同步加载机制，适用于本地文件系统操作
  - 其设计目标是为非浏览器环境提供标准化库支持，涵盖文件系统、I/O 流等基础功能
- ‌**ESM‌**
  - ECMAScript 标准模块系统，具有跨端特性，既能在现代浏览器中运行，也能在 Node.js 环境中使用
  - ESM 支持异步加载，更适合网络环境

2. **如果 ESM 可以跨端 那么 node 为什么不都用 ESM，还继续使用 CommonJS 呢？**

   虽然 ESM 可以跨端，但 Node.js 没有完全放弃 CommonJS 主要有以下原因：

   - ‌ **历史兼容性：** Node.js 生态系统中有大量现有包采用 CommonJS 格式，完全迁移需要时间。在 Node.js 13.2.0 之前，主要使用 CommonJS 模式
   - ‌ **文件扩展名区分：** Node.js 通过文件扩展名来区分模块类型 - .mjs 文件使用 ESM 规范，.cjs 文件使用 CommonJS 规范，而 .js 文件默认采用 CommonJS 标准

   - ‌ **加载机制差异：** CommonJS 是同步加载，在服务器端由于模块存储在本地磁盘，加载速度较快；而 ESM 设计为可以异步加载

3. **与 CommonJS 的关键差异**

   在加载机制上，ESM 是 ‌ `编译时静态加载` ‌ 的，这意味着模块的依赖关系在代码执行前就已确定，这使得打包工具可以进行静态分析，实现如 `Tree Shaking`（消除无用代码）等优化

   ESM 输出的是`值的引用` ‌，所有导入该值的模块都共享同一份内存地址。

#### 主要使用场景

1. **多项目工作区 ‌：**

   在多项目工作区中，可能 ‌ 共用同一个 node_modules 目录，在 Bun 或 pnpm 工作区中，可以为不同项目设置独立的缓存路径，避免冲突

   ```javascript
      // 项目A的vite.config.js
      export default defineConfig({
        cacheDir: '../../node_modules/.vite-project-a'
      })

      // 项目B的vite.config.js
      export default defineConfig({
        cacheDir: '../../node_modules/.vite-project-b'
      })
   ```

2. **CI/CD 环境 ‌：**

   通过环境变量动态控制缓存目录，适应不同的构建环境

   ```yaml
   <!--通过设置不同的CACHE_DIR环境变量，就能让同一个构建脚本在不同环境中使用不同的缓存位置 -->
   build_job:
     cache:
       paths:
         - $CACHE_DIR/node_modules/
     script:
       - npm install
       - npm run build
   ```

   在 CI/CD 配置文件（如 GitLab CI 的`.gitlab-ci.yml`）中定义环境变量，这样可以在不同的构建环境中使用不同的缓存路径

3. **持久化缓存：**

   将缓存目录移到项目根目录下，避免因 `node_modules` 变动导致的缓存失效

4. ‌**缓存清理 ‌：**
   当遇到奇怪的构建问题时，可以通过 `--force` 选项或手动删除缓存目录来重新生成

#### 实际配置示例

```javascript
// vite.config.js
export default defineConfig({
  cacheDir: ".vite_cache", // 自定义缓存目录
});
```

简单来说，cacheDir 就是 Vite 的"记忆仓库"，记住之前做过的工作，避免重复劳动，从而让开发和构建过程更加高效。

---

### resolve.alias

- 类型：Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>

主要作用是为常用路径创建简短的别名，让代码导入更简洁清晰。

#### 为什么要用路径别名？

在大型项目中，你经常会看到这样的导入：

```javascript
import Button from "../../../components/Button";
import utils from "../../../../utils/helpers";
```

使用别名后，代码变得更简洁：

```javascript
import Button from "@components/Button";
import utils from "@utils/helpers";
```

#### 如何配置路径别名？

- 对象写法（最常用）

  ```javascript
  resolve: {
    alias: {
      '@': '/src',
      '@components': '/src/components',
      '@utils': '/src/utils'
    }
  }
  ```

- 数组写法（更灵活）

  ```javascript
  resolve: {
    alias: [
      { find: "@", replacement: "/src" },
      { find: /^@components\/(.*)/, replacement: "/src/components/$1" },
    ];
  }
  ```

#### 重要注意事项

**必须使用绝对路径**

配置别名时一定要用完整路径，不能使用相对路径

```javascript
// ‌正确做法：
'@': path.resolve(__dirname, 'src')

// ‌错误做法：
'@': './src'  // 这样会出问题！
```

#### 关于 SSR 的特殊说明

在服务端渲染（SSR）时，如果你配置了外部依赖的别名，可能需要为真实的 `node_modules` 包也配置别名。使用 `npm: ` 前缀可以让 Yarn 和 pnpm 正确处理这些依赖关系

---

### resolve.dedupe

用于解决依赖重复问题的配置选项，主要作用是强制让相同依赖的不同版本都指向同一个副本

#### 主要用途

‌ 解决依赖冲突问题 ‌：当你的项目中存在相同依赖的多个版本时，比如：

- 项目依赖 A 和 B，它们分别依赖了不同版本的 C
- 直接安装了相同依赖的多个版本
- 在 monorepo（多包仓库）项目中，不同包使用了相同依赖的不同版本

‌ 配置示例 ‌：

```javascript
// vite.config.js
export default {
  resolve: {
    dedupe: ["lodash", "react", "vue"],
  },
};
```

#### 实际效果

- **配置前 ‌：**

  项目中可能同时存在 `lodash@4.17.15` 和 `lodash@4.17.21` 两个版本，导致打包体积增大

- **配置后 ‌：**

  Vite 会强制所有对 `lodash` 的引用都指向同一个版本（通常是项目根目录下的版本），减小最终构建产物体积

#### 关于 SSR + ESM 的特殊说明

在服务端渲染（SSR）场景下，当配置 build.rollupOptions.output 为 ESM（ES Module）格式时，依赖去重功能可能无法正常工作。

‌ **解决方案 ‌：**

可以暂时使用 CJS（CommonJS）构建输出，等待 ESM 在插件中获得更好的模块加载支持。

---

### resolve.conditions

- 类型： string[]
- 默认： ['module', 'browser', 'development|production']

该配置项允许 Vite 根据不同的运行环境（development 或 production）或运行平台（node 或 browser）来选择不同的模块版本。

**通俗来说**

这个配置是在 **使用别人包的时候** 在自己项目的构建工具中设置的，用来控制如何解析包中的不同版本文件。

#### 情景导出的工作原理

当你在代码中导入一个包时，系统会按照 `resolve.conditions` 中的条件顺序来查找最匹配的文件。

‌**举个例子**

```json
// 假设包的 package.json 中有如下配置
{
  "exports": {
    ".": {
      "import": "./index.esm.js",
      "require": "./index.cjs.js",
      "development": "./dev-bundle.js",
      "production": "./prod-bundle.js"
    }
  }
}
```

```javascript
// 在 vite.config.js 中这样配置：
export default {
  resolve: {
    conditions: ["module", "browser", "development"],
  },
};
```

#### 默认条件的含义

- ‌**module‌：** 匹配 ES 模块系统（如 import 语句）
- **browser‌：** 匹配浏览器环境
- **development|production‌：** 根据 process.env.NODE_ENV 的值动态选择

#### 环境变量的作用

`process.env.NODE_ENV` 是标识当前运行环境的关键变量。在开发时通常设置为 `'development'`，部署时设置为 `'production'`。

#### ‌ 工作流程 ‌：

1. 如果你使用 `import` 语句，系统会优先查找 `import` 条件对应的文件
2. 然后根据 `NODE_ENV` 的值选择开发版或生产版文件
3. 最终返回最适合当前环境和模块系统的文件

#### 实际应用场景

这种机制让包作者可以为不同环境提供优化版本：

- 开发环境：包含详细的错误信息和调试工具
- 生产环境：代码经过压缩和优化，体积更小

#### 简单总结：

- ‌ **包作者 ‌：** 在 `package.json` 中定义 `exports` 字段，提供不同环境的文件
- ‌ **包使用者 ‌：** 在构建工具中配置 `resolve.conditions`，告诉工具如何选择文件版本

#### 注意权重问题

‌**关键原则 ‌：条件解析不是按顺序依次匹配，而是寻找"最佳匹配"**

‌**实际情况分析 ‌**

假设你的配置是：

```javascript
conditions: ["module", "browser", "development"];
```

当系统解析包时，它会：

**1.收集所有匹配的条件**

- `"module"` → 匹配 `"./index.esm.js"`
- `"development"` → 匹配 `"./dev-bundle.js"`
- `"browser"` → 可能没有对应的导出，所以不匹配

**2.‌ 从匹配的条件中选择最特定的那个**

- `"development"` 比 `"module"` 更特定
- 因为 `"development"` 针对具体环境，而 `"module"` 只是模块类型

#### 为什么 "development" 更特定？

- `"module"‌`：只是说明这是 ES 模块版本
- `"development"`‌：说明这是**开发环境专用的 ES 模块版本**

开发环境专用版本通常包含：

- 调试信息
- 未压缩的代码
- 额外的错误检查
- 开发工具集成

#### 实际选择逻辑

系统会这样思考：
"用户既在开发环境，又使用 ES 模块 → 我应该给他开发环境专用的 ES 模块版本"

所以最终选择 `"./dev-bundle.js"` 是因为：

- 它已经包含了 ES 模块的特性
- 同时还针对开发环境做了优化

#### 如果你想要普通 ES 模块版本

有两种方法：

- ‌ 调整条件顺序 ‌：`["module", "development", "browser"]`
- ‌ 设置生产环境 ‌：`NODE_ENV=production`

这样系统就会先匹配 `"module"`，然后发现 `"development"` 不匹配（因为是生产环境），最终选择 `"./index.esm.js"`。

简单来说：系统会选择**最符合当前环境的特定版本**‌，而不是简单地按顺序匹配。

---

### resolve.mainFields

用于配置打包工具在解析包的入口点时，按照指定顺序尝试 `package.json` 中的字段列表。

```javascript
// Vite 配置示例
export default {
  resolve: {
    mainFields: ['module', 'jsnext:main', 'jsnext', 'main']
}
```

**工作流程**
当导入一个包时，工具会按照 `mainFields` 数组中的顺序，依次查找 `package.json` 中对应的字段：

- **‌ 首先查找 module 字段 ‌**（ES 模块版本）
- 如果 `module` 字段不存在，则查找 `jsnext:main` 字段（一些旧库使用的 ES6 模块入口）
- 如果 `jsnext:main` 字段也不存在，则查找 `jsnext` 字段
- 最后回退到 `main` 字段（CommonJS 默认入口）

**核心概念**
**完全按照`resolve.mainFields`提供的数组顺序** ‌，在 package.json 中逐个查找对应的字段，并使用第一个找到的有效字段作为入口点。

#### resolve.conditions 和 resolve.mainFields 的区别

- **resolve.conditions**：用于选择不同环境或运行平台的模块版本。
- **resolve.mainFields**：用于指定包的入口文件字段。

vite.config.js 配置示例：

```javascript
import { defineConfig } from "vite";
import path from "path";

export default defineConfig({
  // 项目根目录
  root: process.cwd(),

  // 解析配置
  resolve: {
    // 条件解析配置 - 用于处理exports字段中的条件
    // 需要和package.json中的exports字段中的条件对应
    conditions: ["import", "module", "browser", "default"],

    // 主字段配置 - 用于没有exports字段时的回退
    mainFields: ["browser", "module", "jsnext:main", "main"],
  },

  // 构建配置
  build: {
    outDir: "dist",
    sourcemap: true,
  },

  // 开发服务器配置
  server: {
    port: 3000,
    open: true,
  },
});
```

package.json 配置示例：

```json
{
  "name": "demo-package",
  "version": "1.0.0",
  "type": "module",

  // 传统的入口字段 - 供mainFields使用
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "browser": "./dist/browser/index.js",
  "jsnext:main": "./dist/esnext/index.js",

  // 现代的exports字段 - 具有更高优先级
  "exports": {
    ".": {
      // import条件 - ES模块环境
      "import": {
        "browser": "./dist/esm/browser.js",
        "default": "./dist/esm/index.js"
      },
      // require条件 - CommonJS环境
      "require": {
        "node": "./dist/cjs/node.js",
        "default": "./dist/cjs/index.js"
      },
      // 默认条件
      "default": "./dist/cjs/index.js"
    },
    "./utils": {
      "import": "./dist/esm/utils.js",
      "require": "./dist/cjs/utils.js"
    }
  }
}
```

**‌ 优先级关系 ‌**：`exports` 字段的条件解析优先于 `mainFields` 的字段查找。这种设计确保了现代包可以使用精确的入口控制，同时保持对传统包的兼容性。

---

### resolve.extensions

- 类型： `string[]`
- 默认： `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`

是一个提升开发效率的配置项，它让你在导入模块时可以少打几个字（省略扩展名）。

#### 核心概念

当你使用 `import` 语句导入一个文件时，通常需要写明完整的文件名，包括扩展名，例如 `import './component.js'`。

`resolve.extensions` 的作用就是让你在导入时**可以省略这些扩展名**‌，Vite 会自动按照列表中指定的顺序尝试为你补全

#### 工作机制

Vite 会按照你在`resolve.extensions`数组中配置的顺序，依次尝试为没有扩展名的导入路径添加上扩展名，直到找到存在的文件为止

例如，假设你配置了`extensions: ['.js', '.vue', '.json']`，当你写下`import App from './App'`时，Vite 实际上会依次查找以下文件：

- `./App.js`
- `./App.vue`
- `./App.json`

一旦找到存在的文件，就会**停止搜索**,如果所有扩展名都尝试后仍未找到文件，**则会报错**。

#### 注意事项与最佳实践

- ‌ **谨慎忽略自定义扩展名**

  Vite 官方文档特别提醒，‌ **不建议忽略像 .vue 这样的自定义导入类型的扩展名**

  因为这可能会影响代码编辑器（如 VS Code）的智能提示（IntelliSense）和 TypeScript 的类型支持

- **调整解析顺序 ‌**

  你可以通过调整`extensions`数组中的元素顺序，来改变 Vite 尝试匹配文件的优先级

---

resolve.preserveSymlinks

- 类型： boolean
- 默认： false

#### 路径结构深度解析

```text
/home/user/projects/                    <-- 这是根目录，我们在这里
├── my-library/                        <-- 真实库
│   └── utils.js                      <-- 真实文件
└── my-app/
    ├── node_modules/
    │   └── my-lib                    <-- 符号链接文件 (它的内容是字符串 "../../../my-library/")
    └── src/
        └── main.js
```

#### 关键：站在谁的视角看路径？

‌**符号链接 my-lib 的内容是 `"../../../my-library/"`。** **这个路径是 ‌ 相对于符号链接文件自身的位置**来计算的。

1. ‌**符号链接文件的位置 ‌：** `/home/user/projects/my-app/node_modules/my-lib`
2. **‌ 解析过程：** `（从 my-lib 的位置开始）：`

   - `../` - 向上到 `my-app/node_modules/`
   - `../` - 再次向上到 `my-app/`
   - `../` - 第三次向上到 `projects/`
   - `my-library/` - 到达目标目录。

所以，`my-lib -> ../../../my-library/` 的含义是: **“站在 `my-app/node_modules/` 目录里，向上退三级，然后进入 `my-library/` 目录。**

#### preserveSymlinks 的 false 和 true 到底有什么区别？

当 `my-app/src/main.js` 文件中有这样一行代码：`import { func } from 'my-lib';`

- **情况一：** `preserveSymlinks: false`**（默认）**

  **Vite 的行为：** Vite 会**跟随（resolve）‌**这个符号链接。

  ‌ **路径解析过程：**

  - 找到 my-app/node_modules/my-lib。
  - 读取它的内容，发现它指向 ../../../my-library/。
  - 穿过这个“快捷方式”‌，找到真正的目标：/home/user/projects/my-library/。
  - 最终使用的文件路径是 ‌：/home/user/projects/my-library/utils.js

  **结果：** 无论你的项目结构多复杂，有多少个符号链接指向它，Vite 最终处理的都是**同一个真实的物理文件**。

- **情况二：** `preserveSymlinks: true`

  ‌**Vite 的行为：** Vite **不跟随** 这个符号链接。

  ‌ **路径解析过程：**

  - 找到 `my-app/node_modules/my-lib`。
  - **就此停止**，把它当作一个普通的目录来处理。

  **路径计算方式：**

  - 它不会去计算 `../../../my-library/`。
  - 它会认为`'my-lib'`这个包就位于`my-app/node_modules/my-lib`。
  - 如果这个包内部有文件引用了相对路径（例如 `./utils.js`），Vite 会以符号链接的位置为基准进行计算。

  **最终使用的文件路径是：** `/home/user/projects/my-app/node_modules/my-lib/utils.js`（注意：这个路径可能根本不存在于你的磁盘上！它只是一个“逻辑”路径）。

  ‌**结果**：Vite 处理的是**符号链接本身所代表的那个路径**，而不是背后真实的文件。

#### 总结与类比

| 配置项                    | 行为模式   | 最终处理的文件路径                                   |
| ------------------------- | ---------- | ---------------------------------------------------- |
| `preserveSymlinks: false` | "跟随模式" | `/home/user/projects/my-library/utils.js` (真实文件) |
| `preserveSymlinks: true`  | "保持模式" | `my-app/node_modules/my-lib/utils.js` (逻辑路径)     |

#### ‌ 核心区别 ‌：

- **`false‌`**追求的是**“内容的唯一性”‌** —— 确保所有指向同一地方的链接，最终都处理同一个文件实例，避免重复打包。
- **`true‌`**追求的是**“路径的原始性”‌** —— 保持模块在项目中的路径结构不变。

‌ **实践建议：** 在绝大多数情况下，你都应该使用默认值 `false`。只有在极少数特殊场景下，比如你明确需要基于符号链接的路径来进行某些操作时，才设置为 `true`

---

### html.cspNonce

- 类型： string
- 相关： 内容安全策略（CSP）

#### 配置方法

‌1. 在 vite.config.js 中直接设置

```javascript
// vite.config.js
import { defineConfig } from "vite";

export default defineConfig({
  html: {
    cspNonce: "r4nd0m-n0nc3-v4lu3",
  },
});
```

‌2. 使用环境变量动态生成

```javascript
// vite.config.js
import { defineConfig } from "vite";

export default defineConfig({
  html: {
    cspNonce: process.env.VITE_CSP_NONCE || "default-nonce",
  },
});
```

#### 配套的 CSP 设置

```http
Content-Security-Policy: script-src 'nonce-r4nd0m-n0nc3-v4lu3'; style-src 'nonce-r4nd0m-n0nc3-v4lu3'

```

#### 实际效果

配置成功后，Vite 会自动执行以下操作：

- 为所有 `<script>` 和 `<style>` 标签添加 `nonce="r4nd0m-n0nc3-v4lu3"` 属性
- 在 HTML 的 `<head>` 区域生成 `<meta property="csp-nonce" nonce="PLACEHOLDER" />` 标签
- 确保样式表和模块预加载的 `<link>` 标签也包含 nonce 属性

#### 注意事项

- ‌ 安全性 ‌：nonce 值必须是每次页面加载时随机生成且不可预测的

- ‌ 一致性 ‌：HTTP 头中的 nonce 值必须与配置文件中的值完全匹配

- ‌ 替代方案 ‌：对于需要更精细控制的场景，可考虑使用子资源完整性校验作为补充措施

通过以上配置，Vite 项目就能在启用严格内容安全策略的同时，确保合法资源的正常加载。

#### 工作原理

浏览器在加载页面时，会检查内容安全策略（CSP）规则。只有那些带有正确 nonce 值的脚本和样式资源才会被允许执行。如果攻击者试图注入没有 nonce 或 nonce 值不匹配的恶意脚本，浏览器就会拒绝执行，从而有效防止跨站脚本攻击（XSS）。

简单来说，这就像给你的合法资源都发了一个"安全通行证"，只有持有正确通行证的资源才能通过安全检查并执行

#### 能解决什么问题？

主要用于防御 XSS（跨站脚本）攻击。

#### 什么是 XSS 攻击

XSS 攻击是指攻击者通过在网页中植入恶意脚本代码，当用户浏览该页面时，这些恶意代码会在用户的浏览器中执行，从而窃取用户敏感信息或进行其他恶意操作。

#### XSS 攻击的工作原理

XSS 攻击的核心在于攻击者利用网页应用程序的漏洞，将恶意脚本插入到受攻击的网页上。
当其他用户访问该页面时，这些脚本会在他们的浏览器中执行，可能导致 cookie 被盗、会话被劫持或恶意软件传播等后果。
常见的 XSS 攻击类型包括存储型 XSS（恶意脚本存储在网站数据库中）、反射型 XSS（恶意脚本通过 URL 参数等方式反射回页面）和 DOM 型 XSS（通过修改页面 DOM 结构执行恶意脚本）。

#### CSP Nonce 的防御机制

CSP Nonce（内容安全策略 Nonce）是一种用于防止 XSS 攻击的策略。CSP Nonce 是一个随机字符串，用于在 HTML 页面中验证脚本的来源。当浏览器加载一个页面时，它会检查页面的 CSP 头，并验证所有脚本的来源。如果脚本的来源与 CSP 头中指定的来源不匹配，则浏览器将拒绝执行该脚本。

---

### css.modules

Vite 中用于配置 CSS 模块化行为的选项，主要用来控制 CSS 类名的编译方式和作用域。

#### 类型

```javascript
interface CSSModulesOptions {
  getJSON?: (
    cssFileName: string,
    json: Record<string, string>,
    outputFileName: string,
  ) => void
  scopeBehaviour?: 'global' | 'local'
  globalModulePaths?: RegExp[]
  exportGlobals?: boolean
  generateScopedName?:
    | string
    | ((name: string, filename: string, css: string) => string)
  hashPrefix?: string
  /**
   * default: undefined
   */
  localsConvention?:
    | 'camelCase'
    | 'camelCaseOnly'
    | 'dashes'
    | 'dashesOnly'
    | ((
        originalClassName: string,
        generatedClassName: string,
        inputFile: string,
      ) => string)
}

```

### 参数讲解

### getJSON 回调函数详解

getJSON 是一个在 CSS Modules 处理完成后自动执行的回调函数，它能够让你获取到编译后的类名映射关系。

回调函数接收三个参数：

- `cssFileName`：处理的 CSS 文件名
- `json`：包含编译后类名映射关系的对象
- `outputFileName`：输出文件名

**实际使用示例**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      getJSON: (cssFileName, json, outputFileName) => {
        console.log("处理的CSS文件：", cssFileName);
        console.log("类名映射关系：", json);
        console.log("输出文件：", outputFileName);
      },
    },
  },
});
```

**映射关系获取过程**

```css
/* button.module.css */
.primary-btn {
  background: blue;
}
.secondary-btn {
  background: gray;
}
```

**处理后的输出**

当 Vite 处理上述 CSS 文件时，getJSON 回调会接收到：

- `cssFileName`：'src/components/button.module.css'
- `json`：{ 'primary-btn': 'button_primary-btn_1a2b3c', 'secondary-btn': 'button_secondary-btn_4d5e6f' }
- `outputFileName`：'dist/assets/button.module.css'

**完整配置实例**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      scopeBehaviour: "local",
      generateScopedName: "[name]__[local]__[hash:base64:5]",
      getJSON: (cssFileName, json, outputFileName) => {
        // 将类名映射关系写入文件
        const mappingFile = cssFileName.replace(".css", ".json");
        fs.writeFileSync(mappingFile, JSON.stringify(json, null, 2));
      },
    },
  },
});
```

### scopeBehaviour - 作用域行为

用于控制 CSS 类名的 ‌ 作用域范围 ‌。

两种作用域模式对比

1. `local` - 局部作用域（默认值）

   ```css
   /* 输入样式 */
   .button {
     background: blue;
   }
   .header-title {
     color: black;
   }

   /* 编译后效果 */
   .button__button__abc123 {
     background: blue;
   }
   .header-title__header-title__def456 {
     color: black;
   }
   ```

   **特点：**

   - 每个 CSS 类名都会被**自动重命名**，添加唯一标识符
   - 样式只在**当前模块**内有效，不会影响其他组件
   - 避免样式冲突和污染

2. `global` - 全局作用域

   ```css
   /* 输入样式 */
   .button {
     background: blue;
   }
   .header-title {
     color: black;
   }

   /* 编译后效果（类名保持不变） */
   .button {
     background: blue;
   }
   .header-title {
     color: black;
   }
   ```

   ‌**特点：‌**

   - CSS 类名**保持原样** ‌，不会被重命名
   - 样式具有**全局效果**，会影响整个应用
   - 可能导致样式冲突

**实际应用场景**

- 使用 `local` 的场景：

  - **组件库开发**：确保每个组件的样式独立
  - **大型项目**：防止不同模块间的样式干扰
  - **团队协作**：避免命名冲突

- 使用 `global` 的场景：
  - **全局重置样式**：如 `reset.css`
  - **主题样式**：需要全局应用的配色方案
  - **第三方样式**：需要保持原样的外部 CSS

**配置示例**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      scopeBehaviour: "local", // 或 'global'
      generateScopedName: "[name]__[local]__[hash:base64:5]",
    },
  },
});
```

**开发中的直观感受**

‌ **当使用 `local` 时：‌**

- 在浏览器开发者工具中看到的类名是编译后的（如：`button__button__abc123`）
- 在 JavaScript 中需要通过对象属性访问类名

‌ **当使用 `global` 时：‌**

- 在浏览器中看到的类名与源代码一致（如：`button`）
- 可以直接使用原始类名

**最佳实践建议**

1. 默认使用 `local`：避免样式冲突
2. 特殊情况使用 `global`：如确实需要全局样式
3. 结合 `globalModulePaths`：为特定文件设置全局作用域

通过合理配置作用域行为，可以更好地管理项目的样式体系，确保样式的可维护性和可扩展性。

**如何结合 `globalModulePaths`：为特定文件设置全局作用域：**

在项目中实现**混合作用域**策略：大部分文件使用局部作用域，特定文件使用全局作用域

```javascript
// ‌基础配置结构
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      scopeBehaviour: "local", // 默认局部作用域
      globalModulePaths: [
        // 特定文件
        /\.global\.css$/, // 匹配所有 .global.css 文件
        /node_modules\/.*/, // 匹配 node_modules 中的 CSS 文件
        /src\/styles\/.*/, // 匹配指定目录下的文件
      ],
    },
  },
});
```

### globalModulePaths - 全局模块路径

主要功能是通过正则表达式来**精确控制项目中哪些 CSS 文件应该被当作全局样式处理**，实现局部作用域与全局作用域的灵活结合。

**正则表达式匹配机制**

‌ 项目结构配置

```text
src/
├── components/
│   ├── Button/
│   │   └── button.module.css     // 局部作用域
├── styles/
│   ├── global/
│   │   ├── reset.global.css       // 全局作用域
│   │   └── theme.global.css          // 全局作用域
└── assets/
    └── variables.css                   // 全局作用域
```

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      scopeBehaviour: "local", // 默认局部作用域
      globalModulePaths: [
        /\.global\.css$/, // 匹配所有以 .global.css 结尾的文件
        /node_modules\/.*/, // 匹配 node_modules 目录下的所有文件
        /src\/styles\/.*/, // 匹配 src/styles 目录下的所有文件
      ],
    },
  },
});
```

**不同作用域的效果对比**

```css
/* 全局样式文件 (reset.global.css)： */
/* 输入样式 */
body {
  margin: 0;
  padding: 0;
}

/* 编译后效果（类名保持不变） */
body {
  margin: 0;
  padding: 0;
}
```

```css
/* 局部样式文件 (button.module.css)： */
/* 输入样式 */
.primary {
  background: blue;
}

/* 编译后效果（类名被重命名） */
.button__primary__abc123 {
  background: blue;
}
```

**与 scopeBehaviour 的协同工作**

当您设置 `scopeBehaviour: 'local'` 时：

- 大部分 CSS 文件使用局部作用域
- 只有 `globalModulePaths` 匹配的文件使用全局作用域

**完整配置实例**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      scopeBehaviour: "local",
      generateScopedName: "[name]__[local]__[hash:base64:5]",
      globalModulePaths: [
        /\.global\.css$/, // 全局样式标记文件
        /node_modules\/.*\.css$/, // 第三方库样式
        /src\/assets\/global\/.*/, // 项目全局样式目录
        /src\/styles\/theme\.css/, // 特定主题文件
      ],
    },
  },
});
```

**配置优势总结**

1. **精准控制**：通过正则表达式精确指定全局样式范围
2. **混合策略**：在同一个项目中同时使用局部和全局作用域
3. **命名规范**：通过文件命名约定区分作用域类型
4. **第三方兼容**：确保 node_modules 中的样式正常工作

这种配置方式特别适合大型项目，既能享受 CSS Modules 的样式隔离优势，又能灵活处理需要全局共享的样式资源。

### exportGlobals - 导出全局变量

- 默认值： false
- 类型： boolean

用于控制是否导出全局作用域中的 CSS 类名。

**‌ 核心作用与默认值**

该参数为布尔值，默认值为`false`。当设置为`false`时，使用:`global()`定义的全局 CSS 类名不会被导出到 JavaScript 模块中；当设置为`true`时，即使在 CSS Modules 模式下，也会将这些全局类名暴露为 JavaScript 可访问的对象属性。

**‌ 配置方法**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      exportGlobals: true, // 导出全局 CSS 类名
    },
  },
});
```

**使用场景与限制**

此功能主要应用于需要同时使用 CSS Modules 和全局 CSS 样式的混合开发场景。设置为`true`后，可以在 JavaScript 中获取全局 CSS 类名的字符串值。

**‌ 配合使用的参数**
`exportGlobals` 通常与以下参数协同配置：

- `scopeBehaviour`：定义 CSS Modules 的作用域行为，可选`'local'`（启用模块化）或`'global'`（禁用模块化）
- `globalModulePaths`：指定哪些 CSS 文件被视为全局样式，不应用 CSS Modules
- `localsConvention`：控制导出类名的命名格式

**项目配置实例**

- CSS 文件内容：
  ```css
  /* styles.module.css */
  .localClass {
    color: blue;
  } /* 局部类名 */
  :global(.globalClass) {
    color: red;
  } /* 全局类名 */
  ```
- JavaScript 中使用：

  ```javascript
  import styles from "./styles.module.css";

  // exportGlobals: false 时
  styles.localClass; // 可访问 → "localClass\_哈希值"
  styles.globalClass; // 不可访问 → undefined

  // exportGlobals: true 时
  styles.localClass; // 可访问 → "localClass\_哈希值"
  styles.globalClass; // 也可访问 → "globalClass"
  ```

#### 运行效果对比：‌

- 当 `exportGlobals: false`（默认）：

  - `styles.localClass` → 返回"localClass\_哈希值"（如"localClass_abc123"）
  - `styles.globalClass` → 返回 undefined（无法访问）

- 当 `exportGlobals: true`：

  - `styles.localClass` → 返回"localClass\_哈希值"
  - `styles.globalClass` → 返回"globalClass"（原名字符串）

#### ‌ 简单理解：‌

- `localClass` 是普通类名，CSS Modules 会自动给它加哈希值避免冲突
- `globalClass` 用`:global()`包裹，表示它是全局类名，不会被哈希化
- `exportGlobals` 开关决定你能否在 JavaScript 中访问到这些全局类名

#### :global() 是什么？有什么最用

:global() 在 CSS Modules 中用于声明全局样式规则，使其不受 CSS Modules 的局部作用域限制。
它的核心作用是"停用模块化"，告诉编译器不对:global(...)括号内部的选择器进行哈希化处理，而是原样输出到最终的 CSS 文件中

**需要使用:global()的主要场景**

- ‌ 覆盖第三方组件样式

  当使用第三方 UI 组件库（如 Ant Design、Element UI 等）时，需要通过全局类名来覆盖组件的默认样式
  例如，要修改一个按钮组件的样式：

  ```css
  :global(.ant-btn) {
    background-color: #1890ff;
    border-radius: 6px;
  }
  ```

- 定义全局基础样式

  对于需要在整个应用中生效的基础样式，如重置样式、字体定义、颜色变量等

  ```css
  :global(body) {
    margin: 0;
    font-family: "Arial", sans-serif;
  }
  ```

- ‌ 布局和工具类

  一些通用的布局类（如.container、.row）或工具类（如.text-center、.hidden）需要设置为全局样式，以便多个组件共用

- ‌ 动画关键帧定义

  CSS 动画的`@keyframes`通常需要定义为全局，确保动画在不同组件间正常工作。

**关键特性与优势**

- ‌ **作用域控制**：:global()允许在 CSS Modules 环境中精确控制哪些样式应该是全局的，哪些应该是局部的
- ‌ **避免污染**：通过将全局样式限定在特定类名下，防止真正的全局样式污染
- ‌ **灵活组合**：支持局部样式与全局样式的混合使用

这种机制既保留了 CSS Modules 的隔离优势，又提供了必要的灵活性来处理实际开发中的复杂样式需求。

#### CSS Modules 是什么？

CSS Modules 是一种 CSS 模块化方案，它通过将 CSS 类名局部化来解决全局样式冲突的问题。 CSS Modules 中，每个 CSS 文件都被视为独立的模块，其中定义的类名默认会被编译成唯一的哈希字符串，确保样式仅在该模块内有效。

**CSS Modules 的核心特性包括：**

- ‌ **局部作用域**：默认情况下，CSS Modules 中的类名都具有局部作用域，不会影响其他组件。
- ‌ **类名映射**：在 JavaScript 中导入 CSS 模块时，会得到一个包含原始类名与编译后类名映射关系的对象。
- ‌ **构建工具支持**：CSS Modules 不是 CSS 官方标准，而是通过 webpack 等构建工具实现的。

在 Vue 项目中，CSS Modules 可以作为 Scoped CSS 的替代方案，通过配置 Vue Loader 来启用

CSS Modules 还支持全局样式定义，通过使用`:global()`语法包裹的类名将不会被哈希化，可以在整个应用中使用。

### generateScopedName - 生成作用域类名

专门用于**控制编译后生成的 CSS 类名的格式 ‌。** 其根本目的是为了解决 CSS 的全局命名冲突问题。通过为每个样式文件中的类名生成一个独一无二、具有“作用域”的名称，可以确保不同组件或模块中的同名样式不会相互影响。

**参数类型：**

`string  | ((name: string, filename: string, css: string) => string)`

它既可以接受一个**字符串模板** ‌，也可以接受一个**自定义函数**来精确控制生成的类名。

1.  使用字符串模板 _(这是最常见和简便的配置方式)_

    **常见的占位符包括：**

    - `[name]`: 原始类名（例如`.button`中的`button`）
    - `[local]`: 同 `[name]`，也是原始类名
    - `[hash]`: 基于文件内容生成的哈希字符串，用于确保唯一性
    - `[hash:base64:5]`: 取哈希值的前 5 位，并进行 base64 编码（这是最常用的方式之一）

    **配置示例 (在 vite.config.js 中):**

    ```javascript
    import { defineConfig } from "vite";

    export default defineConfig({
      css: {
        modules: {
          // 使用字符串模板配置 generateScopedName
          generateScopedName: "[name]__[local]___[hash:base64:5]",
        },
      },
    });
    ```

    ```css
    /* ‌编译前‌ (在 ComponentA.module.css 文件中):*/
    .container {
      padding: 10px;
    }
    .title {
      color: blue;
    }
    ```

    ```css
    /* ‌编译后‌ (在最终的 CSS 文件和你的 JavaScript 代码中):*/
    .container__container___a1b2c {
      padding: 10px;
    }
    .title__title___d3e4f {
      color: blue;
    }
    ```

2.  使用自定义函数

    当字符串模板无法满足你的复杂需求时，你可以提供一个函数来完全自定义类名的生成逻辑。

    **函数参数：**

    - `name` (string): 原始的 CSS 类名。
    - `filename` (string): 当前样式文件所在的路径。
    - `css` (string): 当前样式文件的全部内容。

    **‌ 配置示例：**
    假设你想根据不同的文件路径来添加不同的前缀

    ```javascript
    import { defineConfig } from "vite";

    export default defineConfig({
      css: {
        modules: {
          generateScopedName: (name, filename, css) => {
            // 如果文件名包含 'components' 目录，则添加 'comp' 前缀
            if (filename.includes("components")) {
              return `comp_${name}_${Buffer.from(filename)
                .toString("base64")
                .substring(0, 5)}`;
            }
            // 默认情况下，使用简单拼接
            return `app_${name}`;
          },
        },
      },
    });
    ```

    **配置的完整示例**

    ```javascript
    // vite.config.js
    import { defineConfig } from "vite";

    export default defineConfig({
      css: {
        modules: {
          scopeBehaviour: "local", // 默认就是 'local'，开启 CSS Modules
          generateScopedName: "[name]__[local]--[hash:base64:5]", // 自定义类名格式
          localsConvention: "camelCase", // 将 .btn-primary 这样的类名在 JS 中导出为 styles.btnPrimary
        },
      },
    });
    ```

    **总结**

    `generateScopedName`选项为你提供了强大的灵活性，让你能够：

    - **确保样式隔离** ‌：从根本上避免 CSS 类名冲突。
    - **定制类名格式** ‌：通过字符串模板或函数，生成符合你项目命名规范或调试需求的类名。
    - **增强可读性与可调试性** ‌：一个良好的命名格式（如包含原始类名和部分哈希）既能保证唯一性，又能在浏览器开发者工具中让你快速定位到对应的组件和原始样式。

    **‌ 请注意 ‌：** 当 Vite 使用**Lightning CSS**时，此配置项会失效，你需要改用 `css.lightningcss.cssModules` 进行配置。

    ***

    **什么是 Lightning CSS？和 postcss 有什么区别？**

    #### 什么是 Lightning CSS？

    Lightning CSS 是一个 ‌**基于 Rust 编写 ‌**的极速 CSS 处理工具，由 Vite 团队开发并从 Vite 4.4 版本开始实验性支持。

    **核心特点**

    - ‌**极致性能** ‌：可以在单个线程上每秒压缩超过 270 万行代码，转换和打包速度远超 PostCSS‌
    - **内置功能** ‌：集成了 CSS 压缩、语法降级、自动前缀添加和 CSS 模块化功能，无需额外插件 ‌
    - ‌**类型安全** ‌：遵循 CSS 语法规范，为每个值提供规范类型，避免传统解析器无类型 tokens 的问题 ‌
    - ‌**现代特性支持** ‌：原生支持嵌套规则、CSS 变量等新特性，并能智能降级为兼容语法 ‌

    #### 什么是 PostCSS？

    PostCSS 是一个 ‌**基于 JavaScript‌**的 CSS 转换工具，通过插件系统提供丰富的 CSS 处理功能，‌ 它不同于传统的 CSS 预处理器(如 Sass、Less)，不引入新语法，而是通过插件对现有 CSS 代码进行转换和优化 ‌。

    **核心特点**

    - ‌**插件生态丰富** ‌：拥有 autoprefixer、cssnano 等众多插件，覆盖代码格式化、兼容性处理等场景 ‌
    - ‌**高度可定制** ‌：开发者可深度定制代码处理过程，满足项目独特需求 ‌
    - ‌**工作流集成** ‌：能与 Webpack、Gulp 等构建工具无缝配合 ‌
    - ‌**AST 处理** ‌：将 CSS 解析为抽象语法树(AST)进行操作，再生成处理后的 CSS‌

    #### 主要区别对比

    | 对比维度 | Lightning CSS                         | PostCSS                |
    | -------- | ------------------------------------- | ---------------------- |
    | 开发语言 | Rust                                  | JavaScript             |
    | 性能表现 | 快 100 倍以上，每秒处理 270 万行      | 相对较慢，依赖 JS 引擎 |
    | 功能集成 | 内置压缩、降级、前缀等功能            | 需通过插件实现相同功能 |
    | 配置方式 | 通过`css.lightningcss.cssModules`配置 | 通过`css.modules`配置  |
    | 学习曲线 | 配置简单但功能有限                    | 插件系统复杂但灵活     |
    | 适用场景 | 追求极致性能的项目                    | 需要高度定制的项目     |

    #### 总结

    - **Lightning CSS 就像是 Rust 版本的 PostCSS‌**
    - **Lightning CSS** 提供了更快的开发体验和更小的打包体积，特别适合现代前端项目；
    - **PostCSS** 则更适合需要高度定制化处理的老项目或特殊需求场景 ‌

    #### 使用建议

    - 新项目推荐 ‌：在 Vite 4.4+项目中优先使用 Lightning CSS，享受其性能优势 ‌
    - 老项目迁移 ‌：逐步替换 PostCSS 插件为 Lightning CSS 内置功能
    - 特殊需求 ‌：如需复杂处理，可考虑两者结合使用

    ***

### hashPrefix - 哈希前缀

用于**‌ 为生成的哈希类名添加自定义前缀 ‌**。这个前缀会附加在通过`generateScopedName`生成的类名中的哈希部分之前。

**实际配置示例**

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      hashPrefix: "myapp",
      generateScopedName: "[name]__[local]__[hash:base64:5]",
    },
  },
});
```

```css
/* 配置前（无 hashPrefix） */
/* 原始样式：Button.module.css */
.button {
  background: blue;
}
/* 编译后生成的类名可能为 */
.button__button__a1b2c {
  background: blue;
}

/* 配置后（使用 hashPrefix） */
/* 配置 hashPrefix: 'myapp' 后 */
.button__button__myappa1b2c {
  background: blue;
}
```

#### 与其他参数的配合使用

`hashPrefix`需要与`generateScopedName`参数配合使用，它主要影响哈希部分的前缀

### localsConvention - 类名转换规则

控制 CSS Modules 在编译时如何转换和导出类名。

**可选值**

- `camelCase`
- `camelCaseOnly`
- `dashes`
- `dashesOnly`

**实际配置示例**

```css

```

配置示例：

```javascript
// vite.config.js
export default defineConfig({
  css: {
    modules: {
      localsConvention: "camelCase",
    },
  },
});

// css部分
.my-button {
  color: red;
}
.primary-text {
  font-size: 16px;
}

// 'camelCase' 模式（最常用）  同时保留原始类名和生成驼峰式类名‌
import styles from "./Component.module.css";

// 两种方式都可以用：
console.log(styles["my-button"]); // 输出类似：'Component_my-button_abc123'
console.log(styles.myButton); // 输出同上：'Component_my-button_abc123'


// 'camelCaseOnly' 模式  只生成驼峰式类名
import styles from './Component.module.css';
// 只能用驼峰式：
console.log(styles.myButton);    // 输出：'Component_my-button_abc123'
// styles['my-button'] 这种方式将变为 undefined，无法使用。

// 'dashesOnly' 模式  保持原样‌，不进行任何转换。你在CSS里怎么写类名，在JS里就怎么引用
import styles from './Component.module.css';
// 只能用原始带短横线的名字：
console.log(styles['my-button']); // 输出：'Component_my-button_abc123'
// styles.myButton 这种方式将变为 undefined，无法使用。

```

**简单总结与选择**

- **想灵活点，两种写法都能用 ‌：** 选`camelCase`。这对于迁移老项目或团队中有不同习惯的成员很友好
- **想代码风格统一，强制用驼峰 ‌：** 选`camelCaseOnly`。
- **就想保持 CSS 里的原名，不想变：‌**选`dashesOnly`。
